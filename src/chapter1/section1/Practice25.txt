public static int gcd (int x, int y, int count) {
        System.out.println("第" + count + "次调用参数为：" + x + "  " + y);
        if (y == 0) {
            return x;
        }
        return gcd(y, x % y, count + 1);
}

1. 首先证明对任意非负整数，递归一定可以终止， 不难发现， 每次调用第一个参数和第二个参数都是单调递减的，并且从第2次调用开始，第二个参数肯定是小于第一个参数的，所以第2个参数肯定比第一个参数先到0，递归可以正常结束
2. 用数学归纳法证明结果的正确性思路：难点在于找到归纳法的初始状态
    我们这里可以用第一次完成gcd的调用作为初始状态，gcd第一次完成调用肯定是递归的终止那次，也就是第二个参数为0, 任何非负整数与0的最大公约数是该数本身，所以返回第一个参数，gcd求最大公约数成立
    假设第k次完成gcd调用求最大公约数成立，那么我们只要证明第k+1次也成立即可
    不妨设第k次完成gcd的参数为(a, b), 结果为k,  第k+1完成gcd的参数为(c, d), 则我们有以下结论：
        (1) (a, b)最大公约数为k
        (2) d = a, c % d = b
    我们现在只用根据(1)、(2)证明以下结论，最终结论即得证：
        k是(c, d)的最大公约数

    先证k是(c, d)的公约数：
        因为d = a, 所以k是d的约数
        c % d = b ==> c = md + b = ma + b (m为非负整数), 因为k是(a, b)的最大公约数，那么k必然也是c的约数
        k是(c, d)的约数得证
    再证k是(c, d)的最大公约数(反证法)：
        我们假设存在p是(c, d)的最大公约数，并且p > k
        由于a = d, 所以p也是a的约数  (3)
        由于c % d = b, 也即 c = nd + b ==> b = c - nd
        又由于p是(c, d)的最大公约数，所以c = xp, d = yp
        b = c - nd = xp - nyp = (x - ny)p
        即 p也是b的约数   (4)
        结合(3)、(4), p是(a, b)的约数，与k是(a, b)的最大公约数矛盾，所以不存在这样的p

    得证